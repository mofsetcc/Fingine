name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip approval)'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-northeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-1.amazonaws.com
  PROJECT_NAME: kessan
  ENVIRONMENT: prod

jobs:
  # Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    outputs:
      backend-image: ${{ steps.build-backend.outputs.image }}
      frontend-image: ${{ steps.build-frontend.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push backend image
      id: build-backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-backend:prod-${{ github.sha }}
          ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-backend:prod-latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: |
          ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-frontend:prod-${{ github.sha }}
          ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-frontend:prod-latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          REACT_APP_API_URL=https://api.kessan.example.com

    - name: Comprehensive security scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-backend:prod-${{ github.sha }}
        format: 'sarif'
        output: 'backend-security-scan.sarif'
        severity: 'CRITICAL,HIGH'

    - name: Upload security scan results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true
      if: always()
      with:
        sarif_file: 'backend-security-scan.sarif'

    - name: Run production readiness tests
      run: |
        # Add any production-specific tests here
        echo "Running production readiness checks..."
        
        # Check image sizes
        docker images | grep ${{ env.PROJECT_NAME }}
        
        # Verify image metadata
        docker inspect ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-backend:prod-${{ github.sha }}
        docker inspect ${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-frontend:prod-${{ github.sha }}

  # Blue-Green Deployment
  deploy-production:
    name: Deploy to Production (Blue-Green)
    runs-on: ubuntu-latest
    needs: build-and-test
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get current deployment info
      id: current-deployment
      run: |
        # Get current task definition ARNs
        BACKEND_TASK_DEF=$(aws ecs describe-services \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
          --query 'services[0].taskDefinition' --output text)
        
        FRONTEND_TASK_DEF=$(aws ecs describe-services \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend \
          --query 'services[0].taskDefinition' --output text)
        
        echo "backend-task-def=$BACKEND_TASK_DEF" >> $GITHUB_OUTPUT
        echo "frontend-task-def=$FRONTEND_TASK_DEF" >> $GITHUB_OUTPUT

    - name: Create new task definitions
      id: new-task-defs
      run: |
        # Create new backend task definition
        BACKEND_TASK_DEF_JSON=$(aws ecs describe-task-definition \
          --task-definition ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
          --query 'taskDefinition')
        
        # Update image in task definition
        NEW_BACKEND_TASK_DEF=$(echo $BACKEND_TASK_DEF_JSON | jq \
          --arg IMAGE "${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-backend:prod-${{ github.sha }}" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
        
        # Register new backend task definition
        NEW_BACKEND_ARN=$(echo $NEW_BACKEND_TASK_DEF | aws ecs register-task-definition \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' --output text)
        
        # Create new frontend task definition
        FRONTEND_TASK_DEF_JSON=$(aws ecs describe-task-definition \
          --task-definition ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend \
          --query 'taskDefinition')
        
        # Update image in task definition
        NEW_FRONTEND_TASK_DEF=$(echo $FRONTEND_TASK_DEF_JSON | jq \
          --arg IMAGE "${{ env.ECR_REGISTRY }}/${{ env.PROJECT_NAME }}-frontend:prod-${{ github.sha }}" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
        
        # Register new frontend task definition
        NEW_FRONTEND_ARN=$(echo $NEW_FRONTEND_TASK_DEF | aws ecs register-task-definition \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' --output text)
        
        echo "new-backend-arn=$NEW_BACKEND_ARN" >> $GITHUB_OUTPUT
        echo "new-frontend-arn=$NEW_FRONTEND_ARN" >> $GITHUB_OUTPUT

    - name: Deploy new version (Blue-Green)
      id: deploy
      run: |
        # Update backend service with new task definition
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --service ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
          --task-definition ${{ steps.new-task-defs.outputs.new-backend-arn }} \
          --deployment-configuration "maximumPercent=200,minimumHealthyPercent=100"

        # Update frontend service with new task definition
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --service ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend \
          --task-definition ${{ steps.new-task-defs.outputs.new-frontend-arn }} \
          --deployment-configuration "maximumPercent=200,minimumHealthyPercent=100"

    - name: Wait for deployment to stabilize
      run: |
        echo "Waiting for services to stabilize..."
        
        # Wait for backend service
        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend

        # Wait for frontend service
        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend

    - name: Run health checks
      id: health-check
      run: |
        echo "Running health checks..."
        
        # Wait for services to be fully ready
        sleep 60
        
        # Test backend health
        for i in {1..5}; do
          if curl -f https://api.kessan.example.com/health; then
            echo "Backend health check passed"
            break
          fi
          echo "Backend health check failed, attempt $i/5"
          sleep 30
        done
        
        # Test frontend
        for i in {1..5}; do
          if curl -f https://kessan.example.com; then
            echo "Frontend health check passed"
            break
          fi
          echo "Frontend health check failed, attempt $i/5"
          sleep 30
        done
        
        # Run additional smoke tests
        curl -f https://api.kessan.example.com/api/v1/stocks/search?q=toyota || exit 1

    - name: Rollback on failure
      if: failure()
      run: |
        echo "Deployment failed, rolling back..."
        
        # Rollback backend service
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --service ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend \
          --task-definition ${{ steps.current-deployment.outputs.backend-task-def }}

        # Rollback frontend service
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --service ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend \
          --task-definition ${{ steps.current-deployment.outputs.frontend-task-def }}

        # Wait for rollback to complete
        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-backend

        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster \
          --services ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-frontend

    - name: Tag successful deployment
      if: success()
      run: |
        # Tag the commit with deployment info
        git tag -a "prod-deploy-$(date +%Y%m%d-%H%M%S)" -m "Production deployment of ${{ github.sha }}"
        git push origin --tags

    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        custom_payload: |
          {
            "text": "Production Deployment ${{ job.status }}",
            "attachments": [{
              "color": "${{ job.status }}" === "success" ? "good" : "danger",
              "fields": [{
                "title": "Environment",
                "value": "Production",
                "short": true
              }, {
                "title": "Commit",
                "value": "${{ github.sha }}",
                "short": true
              }, {
                "title": "Images",
                "value": "Backend: prod-${{ github.sha }}\nFrontend: prod-${{ github.sha }}",
                "short": false
              }]
            }]
          }
#!/usr/bin/env python3
"""
Master Security and Compliance Validation Script

This script runs all security and compliance validation tests for the Japanese Stock Analysis Platform
including security audit, rate limiting, data encryption, and GDPR compliance validation.
"""

import asyncio
import json
import os
import sys
import subprocess
from datetime import datetime
from typing import Dict, List, Any
import structlog

logger = structlog.get_logger(__name__)


class SecurityValidationSuite:
    """Master security validation suite."""
    
    def __init__(self):
        self.results = {}
        self.overall_status = "UNKNOWN"
        self.start_time = datetime.utcnow()
        
    async def run_all_validations(self) -> Dict[str, Any]:
        """Run all security validation tests."""
        logger.info("Starting comprehensive security and compliance validation")
        
        validation_scripts = [
            {
                "name": "Security Audit",
                "script": "security_audit.py",
                "description": "Comprehensive security audit including authentication, encryption, and configuration"
            },
            {
                "name": "Rate Limiting Test",
                "script": "test_production_rate_limiting.py", 
                "description": "Rate limiting and quota enforcement validation"
            },
            {
                "name": "Data Encryption Test",
                "script": "test_data_encryption.py",
                "description": "Data encryption and secure storage validation"
            },
            {
                "name": "GDPR Compliance Test",
                "script": "test_gdpr_compliance.py",
                "description": "GDPR compliance and privacy validation"
            }
        ]
        
        for validation in validation_scripts:
            logger.info(f"Running {validation['name']}")
            result = await self._run_validation_script(validation)
            self.results[validation['name']] = result
        
        # Determine overall status
        self._determine_overall_status()
        
        # Generate comprehensive report
        await self._generate_comprehensive_report()
        
        end_time = datetime.utcnow()
        duration = (end_time - self.start_time).total_seconds()
        
        logger.info(
            "Security validation suite completed",
            overall_status=self.overall_status,
            duration_seconds=duration
        )
        
        return {
            "overall_status": self.overall_status,
            "results": self.results,
            "duration_seconds": duration,
            "timestamp": end_time.isoformat()
        }
    
    async def _run_validation_script(self, validation: Dict[str, str]) -> Dict[str, Any]:
        """Run a single validation script."""
        script_name = validation["script"]
        script_path = os.path.join(os.path.dirname(__file__), script_name)
        
        if not os.path.exists(script_path):
            return {
                "status": "ERROR",
                "error": f"Script not found: {script_path}",
                "exit_code": -1
            }
        
        try:
            # Run the validation script
            process = await asyncio.create_subprocess_exec(
                sys.executable, script_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=os.path.dirname(__file__)
            )
            
            stdout, stderr = await process.communicate()
            
            # Parse output
            stdout_text = stdout.decode('utf-8') if stdout else ""
            stderr_text = stderr.decode('utf-8') if stderr else ""
            
            # Determine status based on exit code
            if process.returncode == 0:
                status = "PASS"
            elif process.returncode == 1:
                status = "FAIL"
            else:
                status = "ERROR"
            
            # Try to find generated report files
            report_files = self._find_generated_reports(validation["name"])
            
            return {
                "status": status,
                "exit_code": process.returncode,
                "stdout": stdout_text,
                "stderr": stderr_text,
                "report_files": report_files,
                "description": validation["description"]
            }
            
        except Exception as e:
            return {
                "status": "ERROR",
                "error": str(e),
                "exit_code": -1,
                "description": validation["description"]
            }
    
    def _find_generated_reports(self, validation_name: str) -> List[str]:
        """Find report files generated by validation scripts."""
        report_files = []
        current_dir = os.path.dirname(__file__)
        
        # Look for recently created report files
        for filename in os.listdir(current_dir):
            if any(pattern in filename.lower() for pattern in [
                "security_audit_report",
                "rate_limiting_test_report", 
                "encryption_validation_report",
                "gdpr_compliance_report",
                "security_audit_results",
                "rate_limiting_test_results",
                "encryption_validation_results", 
                "gdpr_compliance_results"
            ]):
                file_path = os.path.join(current_dir, filename)
                # Check if file was created recently (within last hour)
                file_time = datetime.fromtimestamp(os.path.getctime(file_path))
                if (datetime.now() - file_time).total_seconds() < 3600:
                    report_files.append(filename)
        
        return report_files
    
    def _determine_overall_status(self):
        """Determine overall validation status."""
        statuses = [result["status"] for result in self.results.values()]
        
        if "ERROR" in statuses:
            self.overall_status = "ERROR"
        elif "FAIL" in statuses:
            self.overall_status = "FAIL"
        elif all(status == "PASS" for status in statuses):
            self.overall_status = "PASS"
        else:
            self.overall_status = "PARTIAL"
    
    async def _generate_comprehensive_report(self):
        """Generate a comprehensive security validation report."""
        end_time = datetime.utcnow()
        duration = (end_time - self.start_time).total_seconds()
        
        # Count results
        passed_count = sum(1 for result in self.results.values() if result["status"] == "PASS")
        failed_count = sum(1 for result in self.results.values() if result["status"] == "FAIL")
        error_count = sum(1 for result in self.results.values() if result["status"] == "ERROR")
        total_count = len(self.results)
        
        # Generate markdown report
        report = f"""# Comprehensive Security and Compliance Validation Report

**Generated:** {end_time.isoformat()}  
**Duration:** {duration:.2f} seconds  
**Overall Status:** {self.overall_status}

## Executive Summary

- **Total Validations:** {total_count}
- **Passed:** {passed_count}
- **Failed:** {failed_count}
- **Errors:** {error_count}
- **Success Rate:** {(passed_count / total_count * 100):.1f}%

## Validation Results

"""
        
        for validation_name, result in self.results.items():
            status_emoji = {
                "PASS": "✅",
                "FAIL": "❌", 
                "ERROR": "⚠️"
            }.get(result["status"], "❓")
            
            report += f"### {status_emoji} {validation_name} - {result['status']}\n\n"
            report += f"**Description:** {result['description']}\n\n"
            
            if result["status"] == "ERROR" and "error" in result:
                report += f"**Error:** {result['error']}\n\n"
            
            if result.get("report_files"):
                report += "**Generated Reports:**\n"
                for report_file in result["report_files"]:
                    report += f"- {report_file}\n"
                report += "\n"
            
            # Include key output excerpts
            if result.get("stdout"):
                stdout_lines = result["stdout"].split('\n')
                # Get last few lines that contain summary information
                summary_lines = [line for line in stdout_lines[-20:] if any(keyword in line.lower() for keyword in [
                    "tests run", "tests passed", "tests failed", "success rate", 
                    "security issues", "compliance issues", "overall status", "validation"
                ])]
                
                if summary_lines:
                    report += "**Key Results:**\n```\n"
                    report += '\n'.join(summary_lines[-10:])  # Last 10 relevant lines
                    report += "\n```\n\n"
            
            if result.get("stderr") and result["status"] == "ERROR":
                report += f"**Error Details:**\n```\n{result['stderr'][:500]}...\n```\n\n"
        
        # Add recommendations
        report += self._generate_recommendations()
        
        # Save comprehensive report
        report_filename = f"comprehensive_security_validation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(report_filename, 'w') as f:
            f.write(report)
        
        # Save detailed results as JSON
        json_filename = f"comprehensive_security_validation_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(json_filename, 'w') as f:
            json.dump({
                "overall_status": self.overall_status,
                "summary": {
                    "total_validations": total_count,
                    "passed": passed_count,
                    "failed": failed_count,
                    "errors": error_count,
                    "success_rate": (passed_count / total_count * 100) if total_count > 0 else 0,
                    "duration_seconds": duration,
                    "timestamp": end_time.isoformat()
                },
                "detailed_results": self.results
            }, f, indent=2)
        
        logger.info(f"Comprehensive reports saved: {report_filename}, {json_filename}")
    
    def _generate_recommendations(self) -> str:
        """Generate security recommendations based on results."""
        recommendations = "\n## Security Recommendations\n\n"
        
        failed_validations = [name for name, result in self.results.items() if result["status"] == "FAIL"]
        error_validations = [name for name, result in self.results.items() if result["status"] == "ERROR"]
        
        if not failed_validations and not error_validations:
            recommendations += "✅ **All security validations passed!** The system demonstrates strong security posture.\n\n"
            recommendations += "### Ongoing Security Practices\n"
            recommendations += "- Continue regular security audits\n"
            recommendations += "- Monitor security logs and alerts\n"
            recommendations += "- Keep security dependencies updated\n"
            recommendations += "- Review and update security policies quarterly\n"
        else:
            if failed_validations:
                recommendations += "### Critical Issues to Address\n"
                for validation in failed_validations:
                    recommendations += f"- **{validation}**: Review detailed report and address identified issues\n"
                recommendations += "\n"
            
            if error_validations:
                recommendations += "### Technical Issues to Resolve\n"
                for validation in error_validations:
                    recommendations += f"- **{validation}**: Fix technical errors preventing validation\n"
                recommendations += "\n"
            
            recommendations += "### General Security Improvements\n"
            recommendations += "- Implement automated security testing in CI/CD pipeline\n"
            recommendations += "- Set up continuous security monitoring\n"
            recommendations += "- Conduct regular penetration testing\n"
            recommendations += "- Provide security training for development team\n"
        
        recommendations += "\n### Compliance Maintenance\n"
        recommendations += "- Schedule quarterly GDPR compliance reviews\n"
        recommendations += "- Update privacy policies as needed\n"
        recommendations += "- Maintain data processing records\n"
        recommendations += "- Test incident response procedures\n"
        
        return recommendations


async def main():
    """Main function to run comprehensive security validation."""
    print("🔒 Starting Comprehensive Security and Compliance Validation Suite")
    print("=" * 80)
    print("This will run all security validation tests:")
    print("1. Security Audit - Authentication, encryption, configuration")
    print("2. Rate Limiting Test - API protection and quota enforcement") 
    print("3. Data Encryption Test - Secure storage and encryption")
    print("4. GDPR Compliance Test - Privacy and data protection")
    print("=" * 80)
    
    suite = SecurityValidationSuite()
    results = await suite.run_all_validations()
    
    print(f"\n🏁 Security Validation Suite Completed")
    print(f"Overall Status: {results['overall_status']}")
    print(f"Duration: {results['duration_seconds']:.2f} seconds")
    
    # Print summary
    passed_count = sum(1 for result in results['results'].values() if result["status"] == "PASS")
    failed_count = sum(1 for result in results['results'].values() if result["status"] == "FAIL")
    error_count = sum(1 for result in results['results'].values() if result["status"] == "ERROR")
    total_count = len(results['results'])
    
    print(f"\n📊 Validation Summary:")
    print(f"- Total Validations: {total_count}")
    print(f"- Passed: {passed_count}")
    print(f"- Failed: {failed_count}")
    print(f"- Errors: {error_count}")
    print(f"- Success Rate: {(passed_count / total_count * 100):.1f}%")
    
    print(f"\n📋 Individual Results:")
    for validation_name, result in results['results'].items():
        status_symbol = {"PASS": "✅", "FAIL": "❌", "ERROR": "⚠️"}.get(result["status"], "❓")
        print(f"  {status_symbol} {validation_name}: {result['status']}")
    
    # Print report files
    all_report_files = []
    for result in results['results'].values():
        all_report_files.extend(result.get('report_files', []))
    
    if all_report_files:
        print(f"\n📄 Generated Reports:")
        for report_file in set(all_report_files):  # Remove duplicates
            print(f"  - {report_file}")
    
    # Return appropriate exit code
    if results['overall_status'] == "PASS":
        print(f"\n✅ ALL SECURITY VALIDATIONS PASSED")
        return 0
    elif results['overall_status'] == "FAIL":
        print(f"\n❌ SECURITY VALIDATION FAILURES DETECTED")
        print("Review individual test reports for details")
        return 1
    elif results['overall_status'] == "ERROR":
        print(f"\n⚠️ SECURITY VALIDATION ERRORS OCCURRED")
        print("Fix technical issues and re-run validation")
        return 2
    else:
        print(f"\n⚠️ PARTIAL SECURITY VALIDATION RESULTS")
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)